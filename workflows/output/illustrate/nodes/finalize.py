"""Finalize workflow: save images and insert into document."""

import logging
import os
import re
import tempfile
from typing import Literal

from ..config import IllustrateConfig
from ..schemas import ImageLocationPlan
from ..state import (
    FinalImage,
    ImageGenResult,
    ImageReviewResult,
    IllustrateState,
    WorkflowError,
)

logger = logging.getLogger(__name__)


def _get_approved_results(
    generation_results: list[ImageGenResult],
    review_results: list[ImageReviewResult],
) -> list[ImageGenResult]:
    """Get generation results that passed review."""
    # Build set of passed location_ids
    passed_ids = {
        r["location_id"] for r in review_results if r.get("passed", False)
    }

    # Also include successful generations that weren't reviewed
    # (e.g., if vision review was disabled)
    reviewed_ids = {r["location_id"] for r in review_results}

    approved = []
    for gen in generation_results:
        if not gen["success"]:
            continue
        loc_id = gen["location_id"]
        if loc_id in passed_ids or loc_id not in reviewed_ids:
            approved.append(gen)

    return approved


def _insert_images_into_markdown(
    document: str,
    final_images: list[FinalImage],
    image_plan: list[ImageLocationPlan],
) -> str:
    """Insert image references into markdown below specified headers.

    Images are inserted as: ![alt](path)

    Attributions are added as small captions below images when required.
    """
    if not final_images:
        return document

    # Build lookup of images by location_id
    images_by_id = {img["location_id"]: img for img in final_images}

    # Process each plan in reverse order (so line numbers stay valid)
    lines = document.split("\n")
    insertions = []  # List of (line_index, markdown_to_insert)

    for plan in image_plan:
        if plan.location_id not in images_by_id:
            continue

        img = images_by_id[plan.location_id]
        header_text = plan.insertion_after_header

        # Find the header line
        header_line_idx = None
        for i, line in enumerate(lines):
            # Match header with varying levels (# ## ### etc.)
            if re.match(r"^#+\s*" + re.escape(header_text) + r"\s*$", line.strip()):
                header_line_idx = i
                break
            # Also try partial match for long headers
            if header_text in line and line.strip().startswith("#"):
                header_line_idx = i
                break

        if header_line_idx is None:
            logger.warning(
                f"Could not find header '{header_text}' for image {plan.location_id}"
            )
            continue

        # Build image markdown
        alt_text = img["alt_text"] or f"Image: {header_text}"
        file_path = img["file_path"]
        image_md = f"\n![{alt_text}]({file_path})\n"

        # Add source attribution based on image type
        image_type = img.get("image_type", "generated")
        if image_type == "public_domain" and img.get("attribution"):
            attr = img["attribution"]
            photographer = attr.get("photographer", "Unknown")
            source = attr.get("source", "")
            source_url = attr.get("source_url", "")
            if source_url:
                image_md += f"\n*Photo by {photographer} via [{source}]({source_url})*\n"
            else:
                image_md += f"\n*Photo by {photographer} via {source}*\n"
        elif image_type == "diagram":
            image_md += "\n*Diagram generated by Claude*\n"
        elif image_type == "generated":
            image_md += "\n*Image generated by Imagen*\n"

        # Insert after the header line
        insertions.append((header_line_idx + 1, image_md))

    # Sort by line index descending and insert
    insertions.sort(key=lambda x: x[0], reverse=True)
    for line_idx, md in insertions:
        lines.insert(line_idx, md)

    return "\n".join(lines)


def _determine_status(
    image_plan: list[ImageLocationPlan],
    final_images: list[FinalImage],
    errors: list[WorkflowError],
) -> Literal["success", "partial", "failed"]:
    """Determine workflow status based on results."""
    if not image_plan:
        return "failed"

    if not final_images:
        return "failed"

    if len(final_images) == len(image_plan):
        return "success"

    # Some images succeeded
    return "partial"


async def finalize_node(state: IllustrateState) -> dict:
    """Finalize workflow: save images to files and insert into markdown.

    This node:
    1. Filters to approved images (passed review)
    2. Saves each image to the output directory
    3. Inserts image references into the markdown
    4. Returns the final illustrated document

    Returns:
        State update with final_images, illustrated_document, status
    """
    config = state.get("config") or IllustrateConfig()
    document = state["input"]["markdown_document"]
    image_plan = state.get("image_plan", [])
    generation_results = state.get("generation_results", [])
    review_results = state.get("review_results", [])
    existing_errors = state.get("errors", [])

    # Get output directory
    output_dir = config.output_dir or state["input"].get("output_dir")
    if not output_dir:
        output_dir = tempfile.mkdtemp(prefix="illustrate_")
        logger.info(f"Using temp directory for images: {output_dir}")

    os.makedirs(output_dir, exist_ok=True)

    # Get approved results
    approved = _get_approved_results(generation_results, review_results)
    logger.info(f"Finalizing {len(approved)} approved images")

    # Save images and build final_images list
    final_images: list[FinalImage] = []
    errors: list[WorkflowError] = []

    # Build lookup for plans
    plans_by_id = {p.location_id: p for p in image_plan}

    for gen_result in approved:
        location_id = gen_result["location_id"]
        plan = plans_by_id.get(location_id)

        if not plan:
            logger.warning(f"No plan found for {location_id}")
            continue

        if not gen_result["image_bytes"]:
            logger.warning(f"No image bytes for {location_id}")
            continue

        # Determine file extension
        image_type = gen_result["image_type"]
        ext = "png"  # Default for diagrams and Imagen
        if image_type == "public_domain":
            # Check if JPEG
            if gen_result["image_bytes"][:2] == b"\xff\xd8":
                ext = "jpg"

        # Save file
        filename = f"{location_id}.{ext}"
        file_path = os.path.join(output_dir, filename)

        try:
            with open(file_path, "wb") as f:
                f.write(gen_result["image_bytes"])
            logger.info(f"Saved image: {file_path}")

            final_images.append(
                FinalImage(
                    location_id=location_id,
                    insertion_after_header=plan.insertion_after_header,
                    file_path=file_path,
                    alt_text=gen_result["alt_text"] or f"Image: {plan.insertion_after_header}",
                    image_type=image_type,
                    attribution=gen_result["attribution"],
                )
            )

        except Exception as e:
            logger.error(f"Failed to save image {location_id}: {e}")
            errors.append(
                WorkflowError(
                    location_id=location_id,
                    severity="error",
                    message=f"Failed to save image: {e}",
                    stage="finalize",
                )
            )

    # Insert images into document
    illustrated_document = _insert_images_into_markdown(
        document=document,
        final_images=final_images,
        image_plan=image_plan,
    )

    # Determine status
    all_errors = existing_errors + errors
    status = _determine_status(image_plan, final_images, all_errors)

    logger.info(
        f"Finalize complete: {len(final_images)}/{len(image_plan)} images, status={status}"
    )

    return {
        "final_images": final_images,
        "illustrated_document": illustrated_document,
        "errors": errors,
        "status": status,
    }
